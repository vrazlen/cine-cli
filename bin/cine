#!/usr/bin/env bash
set -euo pipefail

LIBRARY_BASE="${HOME}/Videos/Library"
DOWNLOAD_DIR="${LIBRARY_BASE}/Incoming"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"

JACKETT_CONFIG="${XDG_CONFIG_HOME}/Jackett/ServerConfig.json"
JACKETT_URL="http://127.0.0.1:9117"
HISTORY_FILE="${XDG_DATA_HOME}/cine-cli/history.jsonl"
LEGACY_HISTORY="${HOME}/.local/share/media/history.jsonl"

INDEXER_PROVIDER="${INDEXER_PROVIDER:-jackett}"
INDEXER_BASE_URL="${INDEXER_BASE_URL:-$JACKETT_URL}"
INDEXER_SEARCH_URL="${INDEXER_SEARCH_URL:-}"
INDEXER_API_KEY="${INDEXER_API_KEY:-}"
INDEXER_TRACKERS="${INDEXER_TRACKERS:-}"
INDEXER_CATEGORIES="${INDEXER_CATEGORIES:-}"
INDEXER_TIMEOUT="${INDEXER_TIMEOUT:-15}"

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "$1 is required but not installed"
    exit 1
  fi
}

require_cmd jq
require_cmd fzf
require_cmd curl
require_cmd mpv
require_cmd aria2c
require_cmd python3

log() {
  local level="$1"
  shift
  echo "[$level] $*" >&2
}

fetch_url_with_retry() {
  local url="${@: -1}"
  local args=("${@:1:$#-1}")
  local retries=2
  local delay=1
  local count=0
  local output

  while [ $count -le $retries ]; do
    if output=$(curl -fsSL "${args[@]}" "$url"); then
      echo "$output"
      return 0
    fi
    count=$((count + 1))
    if [ $count -le $retries ]; then
      log "WARN" "Request failed. Retrying in ${delay}s..."
      sleep "$delay"
    fi
  done
  log "ERROR" "Failed to fetch URL after $retries retries: $url"
  return 1
}

if [ -z "$INDEXER_SEARCH_URL" ]; then
  INDEXER_SEARCH_URL="$INDEXER_BASE_URL/api/v2.0/indexers/all/results"
fi

if [ -z "$INDEXER_API_KEY" ] && [ -f "$JACKETT_CONFIG" ]; then
  INDEXER_API_KEY=$(jq -r '.APIKey // empty' "$JACKETT_CONFIG")
fi

if [ -z "$INDEXER_API_KEY" ]; then
  echo "Indexer API key not found. Set INDEXER_API_KEY or configure Jackett."
  exit 1
fi

mkdir -p "$(dirname "$HISTORY_FILE")" "$DOWNLOAD_DIR"
if [ ! -s "$HISTORY_FILE" ] && [ -s "$LEGACY_HISTORY" ]; then
  cp "$LEGACY_HISTORY" "$HISTORY_FILE"
fi

run_stream() {
  local magnet="$1"
  local title="$2"
  local start_pos="${3:-}"
  local socket="/tmp/mpv-cine-${RANDOM}.sock"

  local start_args=()
  if [ -n "$start_pos" ]; then
    start_args=("--start=${start_pos}")
  fi

  mpv --input-ipc-server="$socket" --force-seekable=yes "${start_args[@]}" "$magnet" &
  local mpv_pid=$!

  MEDIA_TITLE="$title" MEDIA_MAGNET="$magnet" MEDIA_SOCKET="$socket" MEDIA_PID="$mpv_pid" XDG_DATA_HOME="$XDG_DATA_HOME" python3 - <<'PY' &
import json
import os
import socket
import time

xdg_data = os.environ.get("XDG_DATA_HOME", os.path.expanduser("~/.local/share"))
history_file = os.path.join(xdg_data, "cine-cli/history.jsonl")
magnet = os.environ.get("MEDIA_MAGNET", "")
title = os.environ.get("MEDIA_TITLE", "unknown")
socket_path = os.environ.get("MEDIA_SOCKET", "")
try:
    pid = int(os.environ.get("MEDIA_PID", "0"))
except ValueError:
    pid = 0

if not socket_path or pid == 0:
    raise SystemExit(0)

for _ in range(100):
    if os.path.exists(socket_path):
        break
    time.sleep(0.1)

try:
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    sock.connect(socket_path)
    fileobj = sock.makefile("r")
except Exception:
    raise SystemExit(0)

last_pos = 0.0

def get_prop(name):
    try:
        cmd = {"command": ["get_property", name], "request_id": 1}
        sock.sendall((json.dumps(cmd) + "\n").encode())
        line = fileobj.readline()
        if not line:
            return None
        data = json.loads(line)
        return data.get("data")
    except Exception:
        return None

while True:
    try:
        os.kill(pid, 0)
    except OSError:
        break
    pos = get_prop("time-pos")
    if isinstance(pos, (int, float)) and pos > 0:
        last_pos = float(pos)
    time.sleep(2)

try:
    sock.close()
except Exception:
    pass

if magnet and last_pos > 0:
    entry = {
        "title": title,
        "magnet": magnet,
        "pos": int(last_pos),
        "ts": int(time.time())
    }
    os.makedirs(os.path.dirname(history_file), exist_ok=True)
    with open(history_file, "a", encoding="utf-8") as f:
        f.write(json.dumps(entry, ensure_ascii=False) + "\n")
PY

  wait "$mpv_pid"
}

usage() {
  cat <<'USAGE'
Usage: cine [query]
  -r, --resume     Resume a previous item
  -h, --help       Show this help

Interactive prompts are the default UX.
USAGE
}

copy_magnet() {
  local magnet="$1"
  if command -v wl-copy >/dev/null 2>&1; then
    printf "%s" "$magnet" | wl-copy
    echo "Magnet copied to clipboard"
    return 0
  fi
  if command -v xclip >/dev/null 2>&1; then
    printf "%s" "$magnet" | xclip -selection clipboard
    echo "Magnet copied to clipboard"
    return 0
  fi
  echo "Magnet: $magnet"
}

run_download() {
  local magnet="$1"
  start_epoch=$(date +%s)
  aria2c --check-integrity=false --follow-torrent=mem --seed-time=0 --max-connection-per-server=16 --bt-max-peers=200 --dir "$DOWNLOAD_DIR" "$magnet"
  START_EPOCH="$start_epoch" python3 - <<'PY'
import os
import re
import shutil
import time

base = os.path.expanduser("~/Videos/Library")
incoming = os.path.join(base, "Incoming")
movies = os.path.join(base, "Movies")
series = os.path.join(base, "Series")
start_epoch = int(os.environ.get("START_EPOCH", "0"))

os.makedirs(movies, exist_ok=True)
os.makedirs(series, exist_ok=True)

candidates = []
for name in os.listdir(incoming):
    path = os.path.join(incoming, name)
    try:
        mtime = int(os.path.getmtime(path))
    except OSError:
        continue
    if mtime >= start_epoch:
        candidates.append((mtime, path))

if not candidates:
    raise SystemExit(0)

candidates.sort(reverse=True)
path = candidates[0][1]
name = os.path.basename(path)

series_re = re.compile(r"(S\d{1,2}E\d{1,2})|(Season\s*\d+)", re.IGNORECASE)

dest_base = series if series_re.search(name) else movies

dest = os.path.join(dest_base, name)
if os.path.exists(dest):
    ts = int(time.time())
    dest = os.path.join(dest_base, f"{name}-{ts}")

shutil.move(path, dest)
print(f"Moved to: {dest}")
PY
}

action=""
query=""
if [ $# -gt 0 ]; then
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    -r|--resume)
      action="r"
      shift
      ;;
    magnet:*)
      run_stream "$1" "Stream"
      exit 0
      ;;
    *)
      action="n"
      query="$*"
      ;;
  esac
fi

if [ -z "$action" ]; then
  read -r -p "Action [n=New, r=Resume]: " action
  action=${action:-n}
fi

if [ "$action" = "r" ] || [ "$action" = "R" ]; then
  if [ ! -f "$HISTORY_FILE" ] || [ ! -s "$HISTORY_FILE" ]; then
    echo "No history found"
    exit 1
  fi

  history_entries=$(XDG_DATA_HOME="$XDG_DATA_HOME" python3 - <<'PY'
import json
import os

xdg_data = os.environ.get("XDG_DATA_HOME", os.path.expanduser("~/.local/share"))
history_file = os.path.join(xdg_data, "cine-cli/history.jsonl")
entries = []
with open(history_file, "r", encoding="utf-8") as f:
    for line in f:
        line = line.strip()
        if not line:
            continue
        try:
            data = json.loads(line)
        except Exception:
            continue
        ts = data.get("ts", 0)
        title = data.get("title", "unknown")
        magnet = data.get("magnet", "")
        pos = data.get("pos", 0)
        if magnet:
            entries.append((ts, title, magnet, pos))

entries.sort(reverse=True)
for ts, title, magnet, pos in entries[:200]:
    mm = int(pos) // 60
    ss = int(pos) % 60
    print(f"{title} ({mm:02d}:{ss:02d})\t{magnet}\t{pos}")
PY
)

  selection=$(printf "%s\n" "$history_entries" | fzf --with-nth=1 --delimiter="\t" --prompt="Resume: ")
  magnet=$(printf "%s" "$selection" | awk -F"\t" '{print $2}')
  pos=$(printf "%s" "$selection" | awk -F"\t" '{print $3}')

  if [ -z "$magnet" ]; then
    echo "No selection"
    exit 1
  fi

  run_stream "$magnet" "Resume" "$pos"
  exit 0
fi

jq_filter='.Results
| map(select(.MagnetUri != null and .MagnetUri != ""))
| map(.Title as $t | .QualityScore = (if ($t|test("2160p|4k";"i")) then 4 elif ($t|test("1080p";"i")) then 3 elif ($t|test("720p";"i")) then 2 elif ($t|test("480p";"i")) then 1 else 0 end))
| sort_by(.QualityScore, (.Seeders|tonumber))
| reverse
| .[]
| [(.QualityScore | tostring), (.Size | tostring), .Title, (.Tracker // ""), (.Seeders | tostring), .MagnetUri]
| @tsv'

while true; do
  if [ -z "$query" ]; then
    read -r -p "Search query: " query
  fi

  if [ -z "$query" ]; then
    echo "No search query provided"
    continue
  fi

  curl_args=(
    -sG
    --max-time "$INDEXER_TIMEOUT"
    --data-urlencode "Query=$query"
    --data-urlencode "apikey=$INDEXER_API_KEY"
  )

  if [ -n "$INDEXER_TRACKERS" ]; then
    IFS=',' read -r -a trackers <<< "$INDEXER_TRACKERS"
    for tracker in "${trackers[@]}"; do
      tracker="${tracker//[[:space:]]/}"
      if [ -n "$tracker" ]; then
        curl_args+=(--data-urlencode "Tracker[]=$tracker")
      fi
    done
  fi

  if [ -n "$INDEXER_CATEGORIES" ]; then
    IFS=',' read -r -a categories <<< "$INDEXER_CATEGORIES"
    for category in "${categories[@]}"; do
      category="${category//[[:space:]]/}"
      if [ -n "$category" ]; then
        curl_args+=(--data-urlencode "Category[]=$category")
      fi
    done
  fi

  json=$(fetch_url_with_retry "${curl_args[@]}" "$INDEXER_SEARCH_URL") || continue

  if [ -z "$json" ]; then
    log "ERROR" "Empty response from indexer"
    continue
  fi

  if ! echo "$json" | jq empty >/dev/null 2>&1; then
    log "ERROR" "Invalid JSON received from indexer"
    continue
  fi

  entries=$(printf "%s" "$json" | jq -r "$jq_filter")
  if [ -z "$entries" ]; then
    echo "No results for \"$query\". Try another search."
    query=""
    continue
  fi

  selection=$(printf "%s\n" "$entries" | awk -F"\t" '
    function quality_label(score) {
      if (score >= 4) return "4K";
      if (score == 3) return "1080p";
      if (score == 2) return "720p";
      if (score == 1) return "480p";
      return "SD";
    }
    function format_size(bytes) {
      if (bytes == "" || bytes == "null") return "?";
      b = bytes + 0;
      if (b >= 1073741824) return sprintf("%.1fG", b / 1073741824);
      if (b >= 1048576) return sprintf("%.1fM", b / 1048576);
      if (b >= 1024) return sprintf("%.1fK", b / 1024);
      return sprintf("%dB", b);
    }
    {
      q = quality_label($1);
      s = format_size($2);
      title = $3;
      tracker = $4;
      seeders = $5;
      magnet = $6;
      display = sprintf("[%s] [%s] %s [%s] %s seeds", q, s, title, tracker, seeders);
      print display "\t" magnet "\t" title;
    }
  ' | fzf --with-nth=1 --delimiter="\t" --expect=ctrl-d,ctrl-y --prompt="Select (Enter=Stream, Ctrl+D=Download, Ctrl+Y=Copy): ")

  key=$(printf "%s" "$selection" | head -n1)
  line=$(printf "%s" "$selection" | tail -n1)

  if [ -z "$line" ]; then
    echo "No selection"
    exit 1
  fi

  magnet=$(printf "%s" "$line" | awk -F"\t" '{print $2}')
  selected_title=$(printf "%s" "$line" | awk -F"\t" '{print $3}')

  if [ -z "$magnet" ]; then
    echo "No selection"
    exit 1
  fi

  case "$key" in
    ctrl-d)
      run_download "$magnet"
      exit 0
      ;;
    ctrl-y)
      copy_magnet "$magnet"
      query=""
      continue
      ;;
    *)
      run_stream "$magnet" "$selected_title"
      exit 0
      ;;
  esac

done
